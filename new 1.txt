
        
import random
def FindPointsToLay(board,stone):
  stones=[]
  for y in range(len(board)):
    for x in range(len(board)):
      if(board[y][x]==stone):
        stones.append(Point(x,y))

  
  foundPoints=[]
  for p in stones:
    FindAmbientPoints(board,foundPoints,p)
  return foundPoints

def FindAmbientPoints(board,points,center):
  p=center
  
  newPoint=Point(p.X+1,p.Y+1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
      
  newPoint=Point(p.X-1,p.Y-1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
    
  newPoint=Point(p.X+1,p.Y-1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
      
  newPoint=Point(p.X-1,p.Y+1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
    
  newPoint=Point(p.X+1,p.Y+1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
      
  newPoint=Point(p.X,p.Y+1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)
    
  newPoint=Point(p.X,p.Y-1)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)

  newPoint=Point(p.X+1,p.Y)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)

  newPoint=Point(p.X-1,p.Y)
  if CanLay(board,newPoint.X,newPoint.Y) and not HavePoint(points,newPoint):
    points.append(newPoint)



def HavePoint(points,point):
  for p in points:
    if p.Equal(point):
      return True
  return False

def GetOverAllScore(point,board,stone):
  board[point.Y][point.X]=stone
  score=Score(GetLines(board,stone),board)   
  enemyMove=GetBestMove(board,3-stone)
  if score>=5:
    # Can win in this move
    score = 1000
  elif (enemyMove.Score>=3):

    # Predict move in next two steps
    board[enemyMove.Y][enemyMove.X]=3-stone

  
    enemyNextMove=GetBestMove(board,3-stone)
    board[enemyNextMove.Y][enemyNextMove.X]=3-stone
    
    # mix score
    score-=enemyMove.Score

    # print("scores",score,enemyMove.Score,point.X,point.Y)
    if enemyNextMove.Score>=5:
      # print("enemy can win in two move:")
      # enemyMove.Print()
      # myNextMove.Print()
      # enemyNextMove.Print
      score=-500

    # restore board
    board[enemyNextMove.Y][enemyNextMove.X]=0
    board[enemyMove.Y][enemyMove.X]=0
  else:
    # would lose immediately
    score=-1000

  # restore board
  board[point.Y][point.X]=0
  return score
    
def GetNextPoint(board,stone):
  results=[]
  for y in range(len(board)):
    for x in range(len(board)):
      if(board[y][x]==0):
        results.append(Result(GetOverAllScore(Point(x,y),board,stone),x,y))


  best=results[0].Score
  for r in results:
    print("result:",r.Score,r.X,r.Y)
    if r.Score>best:
      best=r.Score
  bestResult=RandomResult(results,best)
  # print("score",best)
  return Point(bestResult.X,bestResult.Y)

def GetBestMove(board,stone):
  results=[]
  for p in FindPointsToLay(board,stone):
    results.append(GetResult(board,p.X,p.Y,stone))

  if(len(results)==0):
    return Result(0,0,0)
  best=results[0].Score
  
  for r in results:
    if r.Score>best:
      best=r.Score
  
  return RandomResult(results,best)

def RandomResult(results,bestScore):
  # print("Avalible results:")
  bestResults=[]
  for r in results:
    if r.Score==bestScore:
      bestResults.append(r)
      r.Print()

  return bestResults[random.randint(0,len(bestResults)-1)]
def Score(lines,board):
  score=0
  for l in lines:
    s=len(l.Points)
    if(s > score and not l.IsDead(board)):
      score=s
  # print("score",score)
  return score

def GetResult(board,stepX,stepY,myStone):
  board[stepY][stepX]=myStone
  res= Result(Score(GetLines(board,myStone),board),stepX,stepY)
  board[stepY][stepX]=0
  return res
def GetLines(board,stone):
  lines=[]
  for y in range(0,len(board)):
    for x in range(0,len(board)):
      if board[y][x]==stone:
        line=Search1(board,Point(x,y),stone)
        if len(line.Points)>1 and not HaveLine(lines,Point(x,y),1):
          lines.append(line)

        line=Search2(board,Point(x,y),stone)
        if len(line.Points)>1 and not HaveLine(lines,Point(x,y),2):
          lines.append(line)

        line=Search3(board,Point(x,y),stone)
        if len(line.Points)>1 and not HaveLine(lines,Point(x,y),3):
          lines.append(line)

        line=Search4(board,Point(x,y),stone)
        if len(line.Points)>1 and not HaveLine(lines,Point(x,y),4):
          lines.append(line)
  return lines




class Result:
  def __init__(self,score,x,y):
    self.Score=score
    self.X=x
    self.Y=y

  def Print(self):
    b=0
    #print(self.Score,self.X,self.Y)

def HaveLine(lines,point,dir):
  for line in lines:
        if line.Direction==dir and line.HasPoint(point):
          return True
  return False


# *
#   *
#     *
def Search1(board,point,stone):
  line=[]
  # forward search
  for i in range(0,len(board)-point.Y):
    if point.Y+i>=len(board) or point.X+i>=len(board[0]):
      break;
    if board[point.Y+i][point.X+i] == stone:
      line.append(Point(point.X+i,point.Y+i))
    else:
      break
    # backward
  for i in range(1,point.Y+1):
    if point.Y-i<0 or point.X-i<0:
      break;
    
    if board[point.Y-i][point.X-i] == stone:
      line.insert(0,Point(point.X-i,point.Y-i))
    else:
      break
  return Line(line,1)
  
#     *
#   *
# *    
def Search2(board,point,stone):
  line=[]
# forward search
  for i in range(0,len(board)-point.Y):
    # print("hehe",point.Y+i,point.X-i)
    if point.Y+i>=len(board) or point.X-i<0:
      break;
    if board[point.Y+i][point.X-i] == stone:
      line.append(Point(point.X-i,point.Y+i))
    else:
      break

# backward
  for i in range(1,point.Y+1):
    if point.Y-i<0 or point.X+i>=len(board):
      break;
    # print("checking",point.Y-i,point.X+i)
    if board[point.Y-i][point.X+i] == stone:
      line.insert(0,Point(point.X+i,point.Y-i))
    else:
      break
  return Line(line,2)

#     
# * * *
#     
def Search3(board,point,stone):
  line=[]
# forward search
  for i in range(0,len(board)-point.X):
    if point.X+i>=len(board):
      break;
    if board[point.Y][point.X+i] == stone:
      line.append(Point(point.X+i,point.Y))
    else:
      break

# backward
  for i in range(1,point.X+1):
    if point.X-i<0:
      break;
    if board[point.Y][point.X-i] == stone:
      line.insert(0,Point(point.X-i,point.Y))
    else:
      break
  return Line(line,3)

#   *     
#   *
#   *    
def Search4(board,point,stone):
  line=[]
# forward search
  for i in range(0,len(board)-point.Y):
    if point.Y+i>=len(board):
      break;
    if board[point.Y+i][point.X] == stone:
      line.append(Point(point.X,point.Y+i))
    else:
      break

# backward
  for i in range(1,point.Y+1):
    if point.Y-i<0:
      break;
    if board[point.Y-i][point.X] == stone:
      line.insert(0,Point(point.X,point.Y-i))
    else:
      break
  return Line(line,4)
  


class Point:
  def __init__(self,x,y):
    self.X=x
    self.Y=y
  def GetDir(self,point2):
      if point2.X-self.X==point2.Y-self.Y:
        return 1
      elif point2.X-self.X==-(point2.Y-self.Y):
        return 2
      elif point2.Y==self.Y:
        return 3
      else:
        return 4
  def Equal(self,point):
    return (point.X==self.X) and (point.Y==self.Y)
    
class Line:
  def __init__(self,points,dir):
    self.Points=points
    self.Direction=dir
  
  def HasPoint(self,point):
    for p in self.Points:
      if(p.Equal(point)):
        return True
    return False
  def IsDead(self,board):
    if(len(self.Points)>=5):
      return False
    first = self.Points[0]
    last = self.Points[len(self.Points)-1]
    if self.Direction == 1:
      return not(CanLay(board,first.X-1,first.Y-1) or CanLay(board,last.X+1,last.Y+1))
    elif self.Direction == 2:
      return not(CanLay(board,first.X+1,first.Y-1) or CanLay(board,last.X-1,last.Y+1))
    elif self.Direction == 3:
      return not(CanLay(board,first.X-1,first.Y) or CanLay(board,last.X+1,last.Y))
    elif self.Direction == 4:
      return not(CanLay(board,first.X,first.Y-1) or CanLay(board,last.X,last.Y+1))
    else:
      return False

def CanLay(board,x,y):
  size = len (board)
  return -1 < x and x < size and -1 < y and y < size and board[y][x] == 0
def PrintLine(line,board):
  print("Direction:",line.Direction,"IsDead",line.IsDead(board),end=",")
  for p in line.Points:
    print('(',p.X,',',p.Y,')',end=",")
  print()




testBoard=[
  [0,0,2,0,0,0],
  [0,1,0,2,0,0],
  [0,0,2,2,2,0],
  [0,0,0,0,1,0],
  [0,0,0,0,1,0],
  [0,0,0,0,1,0]
]
for l in GetLines(testBoard,1):
  b=0
  #PrintLine(l,testBoard)

p=GetNextPoint(testBoard,1)
print(p.X,p.Y)
# print(Score(GetLines(testBoard,1)))